<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Mini Mobile Legend Clone</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body, html {
    height: 100%;
    background: linear-gradient(to top, #1a2a6c, #b21f1f, #fdbb2d);
    font-family: 'Orbitron', sans-serif;
    overflow: hidden;
  }

  #gameCanvas {
    background: #222;
    display: block;
    margin: 0 auto;
    border-radius: 15px;
    touch-action: none;
    user-select: none;
  }

  #ui {
    position: fixed;
    width: 100%;
    max-width: 375px;
    height: 600px;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    pointer-events: none;
  }

  #joystick {
    position: absolute;
    bottom: 80px;
    left: 20px;
    width: 120px;
    height: 120px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    pointer-events: auto;
    touch-action: none;
    user-select: none;
  }

  #stick {
    position: absolute;
    top: 40px;
    left: 40px;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 50%;
    touch-action: none;
    user-select: none;
    transition: top 0.1s, left 0.1s;
  }

  #skillButtons {
    position: absolute;
    bottom: 50px;
    right: 20px;
    width: 180px;
    height: 160px;
    pointer-events: auto;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    align-items: center;
  }

  .skill-btn {
    width: 60px;
    height: 60px;
    background: radial-gradient(circle at center, #ff8000, #cc4e00);
    border-radius: 50%;
    border: 3px solid #fff;
    box-shadow: 0 0 12px #ff8000;
    color: white;
    font-weight: bold;
    font-size: 20px;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }

  .skill-btn:active {
    transform: scale(0.9);
    box-shadow: 0 0 18px #ffa500;
  }

  #scoreBoard {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 18px;
    font-weight: 700;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 6px black;
  }

  #healthBar {
    position: absolute;
    bottom: 160px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 20px;
    background: rgba(255,0,0,0.4);
    border-radius: 10px;
    overflow: hidden;
    pointer-events: none;
    user-select: none;
  }

  #healthFill {
    background: linear-gradient(to right, #ff4c4c, #ff0000);
    height: 100%;
    width: 100%;
    transition: width 0.3s ease;
  }

  /* Mobile fit */
  @media (max-width: 400px) {
    #gameCanvas {
      width: 100vw;
      height: 600px;
      border-radius: 0;
    }
    #ui {
      max-width: 100vw;
      height: 600px;
    }
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="375" height="600"></canvas>

<div id="ui">
  <div id="healthBar">
    <div id="healthFill"></div>
  </div>
  <div id="scoreBoard">Kills: 0</div>
  <div id="joystick">
    <div id="stick"></div>
  </div>
  <div id="skillButtons">
    <div class="skill-btn" data-skill="1">Q</div>
    <div class="skill-btn" data-skill="2">W</div>
    <div class="skill-btn" data-skill="3">E</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Dimensions
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Player config
  const PLAYER_RADIUS = 18;
  const PLAYER_BASE_SPEED = 2.6;
  const PLAYER_MAX_HEALTH = 100;

  // Enemy config
  const ENEMY_RADIUS = 16;
  const ENEMY_SPEED = 1.5;
  const ENEMY_SPAWN_INTERVAL = 2600; // ms

  // Skill config
  const SKILL_COOLDOWN = 5000; // ms
  const SKILL_RADIUS = 8;
  const SKILL_SPEED = 6;
  const SKILL_DAMAGE = 35;

  // Joystick
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  const rectJoystick = joystick.getBoundingClientRect();

  let joystickActive = false;
  let joystickStart = { x: 0, y: 0 };
  let joystickCurrent = { x: 0, y: 0 };

  // UI Elements
  const healthFill = document.getElementById('healthFill');
  const scoreBoard = document.getElementById('scoreBoard');

  // Game State
  let player = {
    x: WIDTH / 2,
    y: HEIGHT / 2 + 100,
    radius: PLAYER_RADIUS,
    speed: PLAYER_BASE_SPEED,
    health: PLAYER_MAX_HEALTH,
    kills: 0,
    lastSkillUsed: [0,0,0],
  };

  let enemies = [];
  let skills = [];

  // Controls state
  let moveDir = { x: 0, y: 0 };
  let skillReady = [true, true, true];

  // Basic utility functions
  function distance(x1, y1, x2, y2){
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
  }

  // Normalize vector
  function normalize(x, y){
    const len = Math.sqrt(x*x + y*y);
    if (len === 0) return {x:0, y:0};
    return {x: x/len, y: y/len};
  }

  // Clamp number
  function clamp(num, min, max){
    return Math.min(Math.max(num, min), max);
  }

  // Draw functions
  function drawCircle(x, y, radius, color, borderColor, borderWidth=2) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    if (borderColor) {
      ctx.lineWidth = borderWidth;
      ctx.strokeStyle = borderColor;
      ctx.stroke();
    }
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawPlayer() {
    ctx.save();

    // Draw aura glow
    const gradient = ctx.createRadialGradient(player.x, player.y, player.radius*0.6, player.x, player.y, player.radius*1.8);
    gradient.addColorStop(0, 'rgba(0, 158, 255, 0.7)');
    gradient.addColorStop(1, 'rgba(0, 158, 255, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius*1.8, 0, Math.PI*2);
    ctx.fill();

    // Draw player circle
    drawCircle(player.x, player.y, player.radius, '#00aaff', '#0066aa', 3);

    // Draw eyes - simple direction indicator
    let eyeOffsetX = moveDir.x * 5 || 0;
    let eyeOffsetY = moveDir.y * 5 || 0;

    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(player.x - 6 + eyeOffsetX, player.y - 6 + eyeOffsetY, 5, 7, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(player.x + 6 + eyeOffsetX, player.y - 6 + eyeOffsetY, 5, 7, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#005577';
    ctx.beginPath();
    ctx.ellipse(player.x - 6 + eyeOffsetX, player.y - 6 + eyeOffsetY, 2, 4, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(player.x + 6 + eyeOffsetX, player.y - 6 + eyeOffsetY, 2, 4, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawEnemy(e) {
    ctx.save();

    // Enemy body
    drawCircle(e.x, e.y, e.radius, '#cc0000', '#880000', 2);

    // Enemy eye (red glowing)
    const eyeX = e.x + (e.vx * 5);
    const eyeY = e.y + (e.vy * 5);

    const gradient = ctx.createRadialGradient(eyeX, eyeY, 1, eyeX, eyeY, 8);
    gradient.addColorStop(0, '#ff4444');
    gradient.addColorStop(1, 'rgba(255, 68, 68, 0)');

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 8, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#441111';
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawSkill(s) {
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#ffaa00';
    ctx.shadowColor = '#ffaa00';
    ctx.shadowBlur = 12;
    ctx.arc(s.x, s.y, SKILL_RADIUS, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Enemy Spawn
  function spawnEnemy(){
    // Spawn from random edge outside canvas
    let pos = {};
    let side = Math.floor(Math.random()*4);
    switch(side){
      case 0: // top
        pos.x = Math.random()*WIDTH;
        pos.y = -ENEMY_RADIUS*2;
        break;
      case 1: // right
        pos.x = WIDTH + ENEMY_RADIUS*2;
        pos.y = Math.random()*HEIGHT;
        break;
      case 2: // bottom
        pos.x = Math.random()*WIDTH;
        pos.y = HEIGHT + ENEMY_RADIUS*2;
        break;
      case 3: // left
        pos.x = -ENEMY_RADIUS*2;
        pos.y = Math.random()*HEIGHT;
        break;
    }
    // Calculate normalized velocity vector toward player
    let dx = player.x - pos.x;
    let dy = player.y - pos.y;
    let norm = normalize(dx, dy);

    enemies.push({
      x: pos.x,
      y: pos.y,
      radius: ENEMY_RADIUS,
      vx: norm.x * ENEMY_SPEED,
      vy: norm.y * ENEMY_SPEED,
      health: 60,
    });
  }

  // Damage function for enemies
  function damageEnemy(index, amount){
    if (!enemies[index]) return;
    enemies[index].health -= amount;
    if (enemies[index].health <= 0) {
      enemies.splice(index, 1);
      player.kills++;
      updateScore();
    }
  }

  // Update Scoreboard
  function updateScore(){
    scoreBoard.textContent = `Kills: ${player.kills}`;
  }

  // Update Health Bar UI
  function updateHealthBar(){
    let healthPercent = clamp(player.health / PLAYER_MAX_HEALTH, 0, 1);
    healthFill.style.width = (healthPercent * 100) + '%';
  }

  // Game Over
  let gameOver = false;
  function triggerGameOver() {
    gameOver = true;
    alert('Game Over! You killed ' + player.kills + ' enemies. Reload to play again.');
  }

  // Game loop update
  function update(){
    if (gameOver) return;

    // Move player by joystick input
    let norm = normalize(moveDir.x, moveDir.y);
    player.x += norm.x * player.speed;
    player.y += norm.y * player.speed;

    // Clamp player inside boundaries
    player.x = clamp(player.x, player.radius, WIDTH - player.radius);
    player.y = clamp(player.y, player.radius, HEIGHT - player.radius);

    // Move enemies toward player
    enemies.forEach(e => {
      e.x += e.vx;
      e.y += e.vy;
    });

    // Move skills
    skills.forEach((s, i) => {
      s.x += s.vx;
      s.y += s.vy;

      // Remove skill if outside canvas
      if (s.x < -SKILL_RADIUS || s.x > WIDTH + SKILL_RADIUS || s.y < -SKILL_RADIUS || s.y > HEIGHT + SKILL_RADIUS) {
        skills.splice(i, 1);
      }
    });

    // Check collisions: Enemy hits player
    enemies.forEach((e,i) => {
      let dist = distance(e.x, e.y, player.x, player.y);
      if (dist < e.radius + player.radius) {
        // Damage player and remove enemy
        player.health -= 20;
        updateHealthBar();
        enemies.splice(i,1);

        if (player.health <= 0) {
          triggerGameOver();
        }
      }
    });

    // Check collisions: Skills hit enemies
    skills.forEach((s,i) => {
      enemies.forEach((e,j) => {
        let dist = distance(s.x, s.y, e.x, e.y);
        if (dist < SKILL_RADIUS + e.radius) {
          damageEnemy(j, SKILL_DAMAGE);
          skills.splice(i,1);
        }
      });
    });
  }

  // Draw function
  function draw(){
    // Clear canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw player
    drawPlayer();

    // Draw enemies
    enemies.forEach(e => {
      drawEnemy(e);
    });

    // Draw skills
    skills.forEach(s => {
      drawSkill(s);
    });
  }

  // Game loop
  function gameLoop(){
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // Joystick events
  joystick.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    joystickActive = true;
    const rect = joystick.getBoundingClientRect();
    joystickStart = { x: e.clientX, y: e.clientY };
    joystickCurrent = { x: e.clientX, y: e.clientY };
    updateStickPosition();
  });

  joystick.addEventListener('pointermove', (e) => {
    if (!joystickActive) return;
    e.preventDefault();
    joystickCurrent = { x: e.clientX, y: e.clientY };

    let deltaX = joystickCurrent.x - joystickStart.x;
    let deltaY = joystickCurrent.y - joystickStart.y;

    // Clamp stick position max radius 40
    const maxDist = 40;
    let dist = Math.min(maxDist, Math.hypot(deltaX, deltaY));
    let angle = Math.atan2(deltaY, deltaX);

    let stickX = dist * Math.cos(angle);
    let stickY = dist * Math.sin(angle);

    stick.style.transform = `translate(${stickX}px, ${stickY}px)`;

    moveDir = { x: stickX / maxDist, y: stickY / maxDist };
  });

  joystick.addEventListener('pointerup', (e) => {
    e.preventDefault();
    joystickActive = false;
    moveDir = { x: 0, y: 0 };
    stick.style.transform = `translate(0px, 0px)`;
  });

  joystick.addEventListener('pointercancel', () => {
    joystickActive = false;
    moveDir = { x: 0, y: 0 };
    stick.style.transform = `translate(0px, 0px)`;
  });

  // Keyboard controls for desktop testing
  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    updateMoveDirFromKeys();
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
    updateMoveDirFromKeys();
  });

  function updateMoveDirFromKeys(){
    if (joystickActive) return; // joystick priority
    let x = 0, y = 0;
    if (keys['arrowup'] || keys['w']) y -= 1;
    if (keys['arrowdown'] || keys['s']) y += 1;
    if (keys['arrowleft'] || keys['a']) x -=1;
    if (keys['arrowright'] || keys['d']) x += 1;
    moveDir = { x, y };
  }

  // Skill buttons handling
  const skillButtons = document.querySelectorAll('.skill-btn');

  skillButtons.forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const skillIndex = parseInt(btn.getAttribute('data-skill')) - 1;
      if (skillReady[skillIndex]) {
        activateSkill(skillIndex);
      }
    });

    btn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const skillIndex = parseInt(btn.getAttribute('data-skill')) - 1;
      if (skillReady[skillIndex]) {
        activateSkill(skillIndex);
      }
    });
  });

  // Skill activation
  function activateSkill(skillIndex) {
    if (!skillReady[skillIndex]) return;
    skillReady[skillIndex] = false;
    player.lastSkillUsed[skillIndex] = Date.now();
    showCooldown(skillIndex);

    // Skill effect: shoot a projectile in moving direction or forward (if no move)
    let dirX = moveDir.x;
    let dirY = moveDir.y;
    if (dirX === 0 && dirY === 0) {
      dirY = -1; // shoot upward by default
    }
    let normDir = normalize(dirX, dirY);

    // Create skill projectile object
    skills.push({
      x: player.x + normDir.x * player.radius,
      y: player.y + normDir.y * player.radius,
      vx: normDir.x * SKILL_SPEED,
      vy: normDir.y * SKILL_SPEED,
      owner: 'player',
      skillId: skillIndex,
    });
  }

  // Visual cooldown effect on skill buttons
  function showCooldown(skillIndex){
    const btn = skillButtons[skillIndex];
    btn.style.pointerEvents = 'none';
    btn.style.opacity = '0.6';

    const cooldownTime = SKILL_COOLDOWN;
    let start = Date.now();

    function cooldownTick(){
      let elapsed = Date.now() - start;
      if (elapsed >= cooldownTime) {
        skillReady[skillIndex] = true;
        btn.style.pointerEvents = 'auto';
        btn.style.opacity = '1';
        return;
      }
      // Visual cooldown fill could be added here if desired
      requestAnimationFrame(cooldownTick);
    }
    cooldownTick();
  }

  // Periodic enemy spawning
  setInterval(() => {
    if (!gameOver) spawnEnemy();
  }, ENEMY_SPAWN_INTERVAL);

  // Initial health bar update
  updateHealthBar();

  // Start game loop
  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>

```