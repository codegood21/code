<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Colorful Abstract Shapes WebGL</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: #111;
    display: flex; justify-content: center; align-items: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script type="text/javascript">
(() => {
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  // Adjust size to window
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  // Vertex shader program
  const vsSource = `
    attribute vec2 aPosition;
    attribute vec3 aColor;
    varying vec3 vColor;

    uniform float uTime;
    uniform vec2 uResolution;

    // 2D rotation matrix
    mat2 getRotation(float angle) {
      float c = cos(angle);
      float s = sin(angle);
      return mat2(c, -s, s, c);
    }

    void main() {
      // Rotate position based on time
      float angle = uTime * 0.5 + aPosition.x * 3.1415;
      vec2 posRot = getRotation(angle) * aPosition;

      // Scale based on y position and time to add dynamic movement
      float scale = 0.4 + 0.15 * sin(uTime * 5.0 + aPosition.y * 30.0);
      vec2 pos = posRot * scale;

      // Project to clipspace (-1 to 1)
      gl_Position = vec4(pos, 0.0, 1.0);
      vColor = aColor;
    }
  `;

  // Fragment shader program
  const fsSource = `
    precision mediump float;
    varying vec3 vColor;

    void main() {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;
  
  function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('An error occurred compiling shaders: ' + gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Initialize shader program
  function initShaderProgram(vsSource, fsSource) {
    const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error('Unable to initialize shader program: ' + gl.getProgramInfoLog(shaderProgram));
      return null;
    }
    return shaderProgram;
  }

  const shaderProgram = initShaderProgram(vsSource, fsSource);
  gl.useProgram(shaderProgram);

  // Look up attribute locations
  const positionLoc = gl.getAttribLocation(shaderProgram, 'aPosition');
  const colorLoc = gl.getAttribLocation(shaderProgram, 'aColor');
  // Uniforms
  const timeLoc = gl.getUniformLocation(shaderProgram, 'uTime');
  const resolutionLoc = gl.getUniformLocation(shaderProgram, 'uResolution');

  // Create buffers
  const positionBuffer = gl.createBuffer();
  const colorBuffer = gl.createBuffer();

  // Function to create random abstract shapes (triangle strips)
  // We'll create multiple colorful triangles randomly positioned and sized
  const shapeCount = 30;
  const verticesPerShape = 3;

  // Positions array: each vertex x,y (-1 to 1 range, relative to shape)
  // Colors array: each vertex r,g,b (0-1)
  let positions = [];
  let colors = [];

  for(let i = 0; i < shapeCount; i++) {
    // Random center within clip space -0.9 to 0.9 for margin
    const cx = (Math.random() * 1.8) - 0.9;
    const cy = (Math.random() * 1.8) - 0.9;
    // Random size
    const size = 0.05 + Math.random() * 0.15;

    // Create an abstract triangle with random offset vertices around center
    for (let v = 0; v < verticesPerShape; v++) {
      // Triangle vertex offsets in circle
      const angle = (v / verticesPerShape) * 2 * Math.PI + Math.random() * 0.4;
      const radius = size * (0.7 + Math.random() * 0.3);
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      positions.push(x, y);

      // Random pastel colors for each vertex
      const r = 0.5 + 0.5 * Math.sin(i + v * 2 + 1.3);
      const g = 0.5 + 0.5 * Math.sin(i + v * 2 + 3.7);
      const b = 0.5 + 0.5 * Math.sin(i + v * 2 + 5.1);
      colors.push(r, g, b);
    }
  }

  // Bind positions
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  // Bind colors
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

  // Enable attributes
  gl.enableVertexAttribArray(positionLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

  gl.enableVertexAttribArray(colorLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

  // Clear color black
  gl.clearColor(0.07, 0.07, 0.07, 1);

  // Draw loop
  let startTime = null;
  function render(time) {
    if (!startTime) startTime = time;
    const elapsedTime = (time - startTime) / 1000; // in seconds

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1f(timeLoc, elapsedTime);
    gl.uniform2f(resolutionLoc, canvas.width, canvas.height);

    // Draw the colored triangles
    gl.drawArrays(gl.TRIANGLES, 0, shapeCount * verticesPerShape);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
})();
</script>
</body>
</html>

```